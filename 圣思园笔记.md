# 圣思园kafka笔记

![consumer-groups](doc/img/p1.png)
### 消息队列的本质
所谓的消息队列就是由生产者向消息队列不断的发送消息，而消费者则是不断从消息队列拉取消息。

### Kafka的本质
Apache Kafka本质上是一款分布式、基于发布订阅机制的消息系统，**主要**使用Scala语言开发而成的。
这里使用了**主要**两字，说明Kafka的源码并非全部都使用Scala语言开发，有相当一部分代码是使用java语言开发的，特别是针对客户端的部分(生产者、消费者等功能模块的代码)。
Kafka的内核基本上都是使用Scala语言开发的，在早期版本的客户端代码中，也是使用Scala语言开发的，
不过在新版的Kafka中，客户端代码部分已经换成了java语言实现，这里所提到的客户端主要是针对于生产者、消费者等功能模块的代码。
在老版本的客户端代码中存在一些已知的问题，因此新版本使用java语言进行了重写，减少了错误发生并增强了稳定性。


•生产者（Producer）：顾名思义， 生产者就是 生产消息的组件，它的主要 工作就是源源不 断地 生产出消息，然后发送给消息队列 。 生产者可以向消息队列 发送各种类型的消息，如狭义的字符串 消息（正如第2节课的示例 所演示的那样，发送了  一个字符串 消息），也可以发送 二进制消息。 生产者是消息队列 的数据来源，只有通过 生产者持续不 断地向消息队列 发送消息，消息队列 才能不 断地处理 消息。

•消费者（Consumer）：消费者的概念也是 比较容易 理 解的。所谓消费者，指的是不 断消费（获取）消息的组件，它获取消息的来源就是消息队列 （即Kafka本身）。换句 话说， 生产者不 断向消息队列 发送消息， 而消费者则不 断从消息队列 中获取消息。这 里  面的消息队列 （即Kafka）则充当了  一个中介的 角 色，连接了  生产者与消费者这两 大功能组件。正是从这个意义上来说，借助于消息队列 ，我们实现了  生产者系统与消费者系统之间的解耦，使得原本需要两个系统之间有紧密联系的状况变成了 两个系统可以各 自针对Kafka进 行 编程（只要提前约定好 一些契约即可），这可以使得 生产者系统完全不 需要了 解消费者系统的各种信息（ 比如说消费者系统的地址、端 口号、URL、

北京圣思园教育

使 用的是REST接 口还是RPC等等；反之亦然）。这正是消息队列 所提供的另外 一个绝佳好处：极 大降低了 系统之间的耦合度。

•代理 （Broker）：代理 这个概念是消息队列 领域中 一个常 见的概念。Broker这个单词原本的意思是经纪 人， 比如说房地产经纪 人、股票经纪 人等。在消息队列 领域中，它指的其实就是消息队列 产品本身， 比如说在Kafka这个领域下，Broker其实指的就是 一台Kafka Server。换句 话说，我们可以将部署的 一台Kafka Server看作是 一个Broker，就是这样简单。那么从流程上来说， 生产者会将消息发送给Broker，然后消费者再从Broker中拉取消息。

•主题（Topic）：主题是Kafka中 一个极为重要的概念。 首先，主题是 一个逻辑上的概念，它 用于从逻辑上来归类与存储消息本身。多个 生产者可以向 一个Topic发送消息，同时也可以有多个消费者消费 一个Topic中的消息。Topic还有分区与副本的概念，这两个概念我们将会在后续课程中遇到时详细介绍。现在，你需要理 解的是，Topic与消息这两个概念之间密切相关，Kafka中的每 一条消息都会归属于某 一个Topic， 而 一个Topic下 面可以有任意数量 的消息。正是借助于Topic这个逻辑上的概念，Kafka将各种各样的消息进 行 了 分 门别类，使得不 同的消息归属于不 同的Topic，这样就可以很好地实现不 同系统的 生产者可以向同 一个Broker发送消息， 而不 同系统的消费者则可以根据Topic的名字从Broker中拉取消息。Topic是 一个字符串 。实际上，在上节课中， 生产者发送消息时就指定了 将消息发送给哪个Topic，在那个示例 中，我们将消息发送给了 名为『mytest』的主题， 而消费者在拉取消息时也指定了 拉取Topic名为『mytest』的消息。通过Topic这样 一个逻辑上的概念，我们就很好地实现了  生产者与消费者之间有针对性的发送与拉取。

•消息（Record）：消息是整个消息队列 中最为基本的 一个概念，也是最为原 子的 一个概念。它指的是 生产者发送与消费者拉取的 一个原 子事物。 一个消息需要关联到 一个Topic上，表示该消息从属于哪个Topic。消息由 一串 字节所构成，其中主要由key和value两部分内容，key与value本质 山都是字节数组。在发送消息时，我们可以省略 掉key部分， 而直接使 用value部分。正如上 一节的示例 那样， 生产者在发送消息时，发送的内容是『hello world』、『welcome』与『 见到你很 高兴』。实际上，他们都是消息的value，即消息真正的内容本身；key的主要作 用则是根据 一定的策略 ，将此消息发送到指定的分区中，这样就可以确保包含同 一key值的消息全部都写 入到同 一个分区中。因此，我们可以得出这样 一个结论：对于Kafka的消息来说，真正的消息内容本身是由value所承载的。为了 提升消息发送的消息和存储效率， 生产者会批量 将消息发送给Broker，并根据相应的压缩算法在发送前对消息进 行 压缩。

北京圣思园教育

•集群（Cluster）：集群指的是由多个Broker所共同构成的 一个整体，对外提供统 一的服务，这类似于我们在部署系统时都会采 用集群的 方式来进 行 。借助于集群的 方式，Kafka消息队列 系统可以实现 高可 用与容错，即 一台Broker挂掉了 也不 影响整个消息系统的正确运 行 。集群中的各台Broker之间是通过 心跳（Heartbeat）的 方式来检测其他机器 是否还存活。

•控制器 （Controller）：控制器 是集群中的概念。每个集群中会选择出 一个Broker担任控制器 的 角 色，控制器 是Kafka集群的中 心。 一个Kafka集群中，控制器 这台Broker之外的其他Broker会根据控制器 的指挥来实现相应的功能。控制器 负责管理 Kafka分区的状态、管理 每个分区的副本状态、监听ZooKeeper中数据的变化并作出相应的反馈等功能。此外，控制器 也类似于主从的概念（ 比如说MySQL的主从概念），所有的Broker都会监听控制器 Leader的状态，当Leader控制器 出现问题或是故障时则重新选择新的控制器 Leader，这 里  面涉及到 一个选举算法的问题。

•消费者组（Consumer Group）：这 又是Kafka中的 一个核 心概念。消费者组与消费者之间密切相关。在Kafka中，多个消费者可以共同构成 一个消费者组， 而 一个消费者只能从属于 一个消费者组。消费者组最为重要的 一个功能是实现 广播与单播的功能。 一个消费者组可以确保其所订阅的Topic的每个分区只能被从属于该消费者组中的唯 一 一个消费者所消费；如果不 同的消费者组订阅了 同 一个Topic，那么这些消费者组之间是彼此独 立的，不 会受到相互的 干扰。因此，如果我们希望 一条消息可以被多个消费者所消费，那就可以将这些消费者放置到不 同的消费者组中，这实际上就是 广播的效果；如果希望 一条消息只能被 一个消费者所消费，那么就可以将这些消费者放置到同 一个消费者组中，这实际上就是单播的效果。因此，我们可以将消费者看作是『逻辑上的订阅者』， 而物理 上的订阅者则是各个消费者。值得注意的是，消费者组是 一个 非常、 非常、 非常重要的概念。很多Kafka初学者都会遇到这样 一个问题：将系统以集群的形式部署（ 比如说部署到3台机器 或是虚拟机上），每台机器 的指定代码都是完全 一样的，那么在运 行 时，只会有 一台机器 会持续不 断地收到Broker中的消息， 而其他机器 则 一条消息也收不 到。究其本质，系统部署时采 用了 集群部署，因此每台机器 的代码与配置都是完全 一样的；这样，这些机器 （消费者）都从属于同 一个消费者组，既然从属于同 一个消费者组，那么这同 一个消费者组中，只会有 一个消费者会接收到消息， 而其他消费者则完全接收不 到任何消息，即单播的效果。这 一点尤其值得 大家注意。
















































































































